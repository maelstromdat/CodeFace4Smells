#! /usr/bin/env Rscript

## This file is part of Codeface. Codeface is free software: you can
## redistribute it and/or modify it under the terms of the GNU General Public
## License as published by the Free Software Foundation, version 2.
##
## This program is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
## details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
## Copyright 2013 by Siemens AG, Wolfgang Mauerer <wolfgang.mauerer@siemens.com>
## All Rights Reserved.

## Socio-technical analysis based on core and ml analysis results
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(igraph))
suppressPackageStartupMessages(library(xtable))

source("developer_classification.r")
source("config.r")
source("query.r")
source("timezones.r")

set.seed(432)

############################# Network utility #################################

## Create and return an undirected graph based on the output of VCS analysis
load.code.graph <- function(rangedir) {
  ## load collaborations from the adjacency matrix generated by VCS analysis
  mat.file <- paste(rangedir, "/adjacencyMatrix.txt", sep="")
  adj.matrix <- read.table(mat.file, sep="\t", header=TRUE)
  adj.matrix.ids <- unlist(strsplit(readLines(mat.file, n=1), "\t"))
  colnames(adj.matrix) <- rownames(adj.matrix)
  ## The adjacency matrix file format uses a different convention for edge
  ## direction than GNU R, so we need to transpose the matrix
  adj.matrix <- t(adj.matrix)
  ## Generate the graph and assign db ids and devs names to vertices
  code.graph <- graph_from_adjacency_matrix(adj.matrix, mode="undirected", 
                                            diag=FALSE, weighted=TRUE)
  names <- lapply(adj.matrix.ids, function(id) { get.person.name(conf$con, id) })
  V(code.graph)$name <- as.character(names)
  V(code.graph)$id <- adj.matrix.ids
  ## simplify the graph removing multiple edges and loops
  code.graph <- simplify(code.graph, remove.multiple=TRUE, remove.loops=TRUE,
                         edge.attr.comb="sum")
  
  return(code.graph)
}

## Create and return an undirected graph based on the output of ml analysis
load.mailinglist.graph <- function(conf, start.date, end.date) {
  ## retrieve communications from db
  res <- query.mail.edgelist(conf$con, conf$pid, start.date, end.date)
  ## if we do not have email collaboration data, terminate the analysis
  loginfo(start.date)
  loginfo(end.date)
  if (length(res) == 0) {
    loginfo("Missing mailing lits data. Terminating..")
    stop()
  }
  ## Generate the graph and assign db ids and devs names to vertices
  mail.graph <- graph.data.frame(res, directed=FALSE)
  ids <- V(mail.graph)$name
  names <- lapply(ids, function(id) { get.person.name(conf$con, id) })
  V(mail.graph)$name <- names
  V(mail.graph)$id <- ids
  ## simplify the graph removing multiple edges and loops
  mail.graph <- simplify(mail.graph, remove.multiple=TRUE, remove.loops=TRUE,
                         edge.attr.comb="sum")
  
  return(mail.graph)
}

## Given in input the collaboration and the communication networks
## merge them into a global network and return it
load.global.graph <- function(mail.graph, code.graph) {
  ## use communication network as starting point
  global.graph <- mail.graph
  
  ## add code-only devs
  for (dev.id in V(code.graph)$id){
    if (!(dev.id %in% V(global.graph)$id)) {
      global.graph <- add_vertices(global.graph, 1, name=V(code.graph)[V(code.graph)$id == dev.id]$name, 
                                   id=dev.id)
    }
  }
  
  ## If only one code developer or no collaborations, we are done
  if ((length(V(code.graph)$id) == 1) | (length(E(code.graph)) == 0)) {
    return(global.graph)
  }
  
  ## retrieve collaboration edges and add them to the global graph
  code.df <- get.data.frame(code.graph)
  for (edge in 1:nrow(code.df)) {
    name1 <- code.df[edge, 1]
    name2 <- code.df[edge, 2]
    weight <- code.df[edge, 3]
    ## add weighted collaboration to the global graph
    global.graph <- add_edges(global.graph, c(V(global.graph)[V(global.graph)$name %in% name1], 
                                              V(global.graph)[V(global.graph)$name %in% name2]), weight=weight)
  }

  ## simplify the graph removing multiple edges and loops
  global.graph <- simplify(global.graph, remove.multiple=TRUE, remove.loops=TRUE,
                           edge.attr.comb="sum")
  
  return(global.graph)
}


############################### Community Smells####################################

## Check the presence of organisational silo community smell.
## Given the communication and collaboration graphs (mailing lists and VCS)
## return the collaboration edges, analyzed in groups of two devs, in
## which one of co-committing devs do not communicate at all.
community.smell.organisational.silo <- function (mail.graph, code.graph) {
  ## discover develpers not present in the mailing list graph
  non.communicative.ids <- setdiff(V(code.graph)$id, V(mail.graph)$id)
  silos <- list()
  ## for each non communicative developer, save its collaborations
  for (vert in non.communicative.ids) {
    for (collab in neighbors(code.graph, V(code.graph)[V(code.graph)$id == vert])$id) {
      ## if both are non-communicative count the collaboration only once to avoid
      ## counting them twice due to the undirected nature of the graph
      if ((collab %in% non.communicative.ids) & (collab < vert)) {
        next() 
      }
      ## organisational silo smell detected
      silos[[length(silos) + 1]] <- c(vert, collab)
    }
  }
  
  return(silos)
}

## Check the presence of missing links community smell.
## Given the communication and collaboration graphs (mailing lists and VCS)
## return the collaboration edges that do not have a communication counterpart.
## It is possible to pass precomputed organisational silo community smell.
community.smell.missing.links <- function (mail.graph, code.graph, precomputed.silo=NA) {
  missing <- list()
  for (vert in V(code.graph)$id) {
    if (!(vert %in% V(mail.graph)$id)) {
      next() # the case of one dev not present in the mailing list is handled later
    }
    for (coll in neighbors(code.graph, V(code.graph)[V(code.graph)$id == vert])$id) {
      if (coll > vert) {
        next() # avoid to check twice a graph due to its undirected nature
      }
      if (!(coll %in% V(mail.graph)$id)) {
        next() # the case of one dev not present in the mailing list is handled later
      }
      ## if a missing communication link is found, it is saved
      if (!(coll %in% neighbors(mail.graph, V(mail.graph)[V(mail.graph)$id == vert])$id)) {
        missing[[length(missing) + 1]] <- c(vert, coll)
      }
    }
  }
  
  ## if no precoumputed organisational silo we are done
  if (length(precomputed.silo) == 0){
    return(missing)
  }
  
  ## If organisational silo is not pre-computed, calculate it
  if (is.na(precomputed.silo)){
    precomputed.silo <- community.smell.organisational.silo(mail.graph, code.graph)
  }
  ## Add the missing links due to developers abstence in the mailing lists
  for (edge in precomputed.silo) {
    missing[[length(missing) + 1]] <- edge
  }
  
  return(missing)
}

## Check the presence of potential black cloud community smell.
## "Potential" because it is an actual smell if iterated over time.
## Given the communication graph and its sub-communities 
## return the communication edges potentially causing the community smell.
community.smell.potential.black.cloud <- function (mail.graph, clusters) {
  black.links <- list()
  memships <- membership(clusters)
  ## For every sub-community check how many edges connect it to another
  ## sub-community. If there is just one extra-cluster edge, we have
  ## a possible black cloud
  for (clust in 1:length(clusters)) {
    extra.clust.links <- list()
    for (vert in V(mail.graph)[memships == clust]$id) {
      for (neigh in neighbors(mail.graph, V(mail.graph)[V(mail.graph)$id == vert])$id) {
        if (memships[V(mail.graph)[V(mail.graph)$id == neigh]] != clust) {
          extra.clust.links[[length(extra.clust.links) + 1]] <- c(vert, neigh) 
        }
      }
    }
    if (length(extra.clust.links) == 1) {
      # Possible black cloud smell detected
      black.links[[length(black.links) + 1]] <- extra.clust.links[[1]]
    }
  }

  return(black.links)
}

## Check the presence of prima-donnas community smell.
## Given the communication graph, its sub-communities and the collaboration
## graph, return the sub-community ids behaving as prima-donnas.
## It is possible to specify the threshold to consider two sub-communities collaborating.
## It is possible to re-use pre-computed potential black links
community.smell.primadonnas <- function (mail.graph, clusters, code.graph, collaboration=0.2, 
                                         precomputed.black=NA) {
  primadonnas <- list()
  memships <- membership(clusters)
  comms <- communities(clusters)
  ## For every potential black-cloud, check the collaboration of the involved sub-communities.
  ## if it is greater than the threshold, we have two prima-donnas
  
  ## if no potential black cloud we are done
  if (length(precomputed.black) == 0){
    return(primadonnas)
  }
  
  if (is.na(precomputed.black)) {
    precomputed.black <- community.smell.potential.black.cloud(mail.graph, clusters)
  }
  for (black.link in precomputed.black) {
    sub.comm.connections <- 0
    ## retrieve cluster identifier of the two sub-communities
    id.clust1 <- memships[V(mail.graph)[V(mail.graph)$id == black.link[1]]]
    id.clust2 <- memships[V(mail.graph)[V(mail.graph)$id == black.link[2]]]
    ## count inter-collaborations of the two sub-communities
    for (dev.clust1 in V(mail.graph)[memships == id.clust1]$id) {
      if (!(dev.clust1 %in% V(code.graph)$id)) {
        next() # ignore devs present only in the communication graph
      }
      for (dev.clust2 in V(mail.graph)[memships == id.clust2]$id) {
        if (!(dev.clust2 %in% V(code.graph)$id)) {
          next() # ignore devs present only in the communication graph
        }
        if (dev.clust1 %in% neighbors(mail.graph, V(mail.graph)[V(mail.graph)$id == dev.clust2])$id) {
          sub.comm.connections <- sub.comm.connections + 1
        }
      }
      ## If the fraction of present collaborations over the total possible collaborations
      ## (Number of devs of clust1 * Number of devs of clust2) then we have two prima-donnas
      tot.possible.collaborations <- length(comms[[id.clust1]]) * length(comms[[id.clust2]])
      if ((sub.comm.connections / tot.possible.collaborations) > collaboration) {
        ## prima-donnas effect detected
        primadonnas[[length(primadonnas) + 1]] <- c(id.clust1, id.clust2)
      }
    }
  }
  
  return(primadonnas)
}

## Check the presence of radio silence community smell.
## Given the communication graph and its sub-communities,
## return the ids of unique boundary spanners towards another
## sub-community, generation this smell.
community.smell.radio.silence <- function (mail.graph, clusters) {
  brockers <- c()
  memships <- membership(clusters)
  ## consider every communication outside each cluster and if there is just one
  ## communication edge from a sub-community toward another one, we have a
  ## radio silence smell (unique boundary spanner)
  for (clust in 1:length(clusters)) {
    ## If a cluster has only one dev, he is an unique boundary spanner
    if (length(V(mail.graph)[memships == clust]$id) == 1) {
      brockers[length(brockers) + 1] <- V(mail.graph)[memships == clust]$id
      next()
    }
    extra.clust.links <- list()
    for (vert in V(mail.graph)[memships == clust]$id) {
      for (neigh in neighbors(mail.graph, V(mail.graph)[V(mail.graph)$id == vert])) {
        ## Note: neigh is the local graph vertex id, not the developer id
        if (clust != memships[neigh]) {
          ## for each outgoing edge, save the cluster developer id and the destination
          ## sub-community id
          extra.clust.links[[length(extra.clust.links) + 1]] <- c(vert, memships[neigh])
        }
      }
    }
    ## for each outgoing edge, substitute destination vertex with its community
    if (length(extra.clust.links) > 0) {
      ## change format to enable comparisons
      extra.clust.links <- matrix(unlist(extra.clust.links), ncol=2, byrow=TRUE)
      for (outClust in unique(extra.clust.links[, 2])) {
        from.dev <- which(extra.clust.links[, 2] == outClust)
        if (length(from.dev) == 1) {
          ## radio silence community smell detected
          brockers[length(brockers) + 1] <- extra.clust.links[from.dev, 1]
        }
      }
    }
  }
  
  return(unique(brockers))
}


########################## Socio-technical metrics ###############################

## Compute and return an extimation of socio-technical conguence
community.metric.sociotechnical.congruence <- function (mail.graph, code.graph) {
  missing.collaborations <- length(community.smell.missing.links(mail.graph, code.graph))
  healthy.collaborations <- length(E(code.graph)) - missing.collaborations
  congruence <- healthy.collaborations / (length(E(code.graph)))
  if (is.na(congruence)) {
    congruence <- 1
  }
  return(congruence)
}

## Compute and return the mean value of decision communicability.
## communicability is computed as (1 - mean(in-communicability))
community.metric.mean.communicability <- function (mail.graph, code.graph) {
  ## If no collaborations, communicability is 1
  if (length(E(code.graph)) == 0) {
    return(1)
  }
  
  ## for each collaboration compute its in-communicability value
  collaborations <- get.edgelist(code.graph)
  mai <- c()
  for (coll in 1:length(E(code.graph))) {
    id.dev1 <- V(code.graph)[V(code.graph)$name == collaborations[coll, 1]]$id
    id.dev2 <- V(code.graph)[V(code.graph)$name == collaborations[coll, 2]]$id
    neigh1 <- neighbors(code.graph, V(code.graph)[V(code.graph)$id == id.dev1])$id
    neigh2 <- neighbors(code.graph, V(code.graph)[V(code.graph)$id == id.dev2])$id
    code.neighbors <- unique(union(neigh1, neigh2))
    dem <- length(code.neighbors) / length(V(code.graph))
    neigh1.mail <- c()
    neigh2.mail <- c()
    if (id.dev1 %in% V(mail.graph)$id) {
      neigh1.mail <- neighbors(mail.graph, V(mail.graph)[V(mail.graph)$id == id.dev1])$id
    }
    if (id.dev2 %in% V(mail.graph)$id) {
      neigh2.mail <- neighbors(mail.graph, V(mail.graph)[V(mail.graph)$id == id.dev2])$id
    }
    mail.neighbors <- intersect(unique(union(neigh1.mail, neigh2.mail)), code.neighbors)
    dam <- length(mail.neighbors) / length(V(code.graph))
    mai[length(mai) + 1] <- dem - dam
  }
  
  return(1-mean(mai))
}


######################################## REPORTS ############################################

## create graphs from the global report data
create.global.report.graphs <- function(sociotechdir) {
  repo <- read.csv(file.path(sociotechdir, "report.csv"))
  pdf(file.path(sociotechdir, "graphs.pdf"))
  col.id <- c("#F15854", "#5DA5DA", "#60BD68", "BLACK", "#FAA43A", "#B276B2", "#DECF3F", "#F17CB0", "#B2912F")
  ## Developers
  plot(repo$devs, type="o", col=col.id[1], ylim=c(0, max(repo$devs)), xaxt="n", ann=FALSE)
  axis(1, at=seq(1, length(repo$range), 1))
  abline(h=seq(0, max(repo$devs), 20), v=1:length(repo$range), col="gray", lty=3)
  lines(repo$ml.only.devs, type="o", col=col.id[2])
  lines(repo$code.only.devs, type="o", col=col.id[3])
  lines(repo$ml.code.devs, type="o", col=col.id[4])
  lines(repo$sponsored.devs, type="o", col=col.id[5])
  title(main="Developers", col.main="red", font.main=4)
  title(xlab="Ranges")
  title(ylab="# developers")
  box()
  legend("topright", c("All devs", "Comm. only", "Coll. only", "Comm. & Coll.",
                      "Sponsored"), 
         cex=0.6, bg="white", fill=col.id)
  
  ## core devs
  maxy <- max(repo$core.code.devs, repo$core.mail.devs, repo$core.global.devs, repo$sponsored.core.devs)
  plot(repo$core.code.devs, type="o", col=col.id[1], ylim=c(0,maxy), xaxt="n", ann=FALSE)
  abline(h=seq(0, max(repo$core.global.devs), 10), v=1:length(repo$range), col="gray", lty=3)
  axis(1, at=seq(1, length(repo$range), 1))
  lines(repo$core.mail.devs, type="o", col=col.id[2])
  lines(repo$core.global.devs, type="o", col=col.id[3])
  lines(repo$sponsored.core.devs, type="o", col=col.id[4])
  title(main="Core developers", col.main="red", font.main=4)
  title(xlab="Ranges")
  title(ylab="# developers")
  box()
  legend("topright", c("Collaboration", "Communication", "Global", "Sponsored"), 
         cex=0.6, bg="white", fill=col.id)
  
  ## Community smells
  maxy <- max(repo$org.silo, repo$prima.donnas, repo$radio.silence ,repo$black.cloud, repo$missing.links)
  plot(repo$org.silo, type="o", col=col.id[1], ylim=c(0, maxy), xaxt="n", ann=FALSE)
  axis(1, at=seq(1, length(repo$range), 1))
  abline(h=seq(0, maxy, 20), v=1:length(repo$range), col="gray", lty=3)
  lines(repo$prima.donnas, type="o", col=col.id[2])
  lines(repo$radio.silence, type="o", col=col.id[3])
  lines(repo$black.cloud, type="o", col=col.id[4])
  lines(repo$missing.links, type="o", col=col.id[5])
  title(main="Community smells", col.main="red", font.main=4)
  title(xlab="Ranges")
  title(ylab="# community smells")
  legend("topright", c("org.silo", "prima-donnas", "radio silence", "black-cloud", "missing links"), 
         cex=0.6, bg="white", fill=col.id)
  
  ## Truck number
  plot(repo$global.truck, type="o", col=col.id[1], ylim=c(0, 1), xaxt="n", ann=FALSE)
  axis(1, at=seq(1, length(repo$range), 1))
  abline(h=seq(0, 1, 0.1), v=1:length(repo$range), col="gray", lty=3)
  lines(repo$mail.truck, type="o", col=col.id[2])
  lines(repo$code.truck, type="o", col=col.id[3])
  title(main="Truck number", col.main="red", font.main=4)
  title(xlab="Ranges")
  title(ylab="Truck number (%)")
  legend("topright", c("Global truck num", "Comm. truck num", "Coll. truck num"), cex=0.6, bg="white", fill=col.id)
  
  ## Turnover
  maxy <- max(1, repo$global.turnover, repo$code.turnover)
  plot(repo$global.turnover, type="o", col=col.id[1], ylim=c(0, maxy), xaxt="n", ann=FALSE)
  abline(h=seq(0, maxy + 0.1, 0.1), v=1:length(repo$range), col="gray", lty=3)
  axis(1, at=seq(1, length(repo$range), 1))
  lines(repo$code.turnover, type="o", col=col.id[2])
  title(main="Turnover", col.main="red", font.main=4)
  title(xlab="Ranges")
  title(ylab="Turnover (%)")
  legend("topright", c("Global", "Collaboration"), cex=0.6, bg="white", fill=col.id)

  ## Core turnover
  maxy <- max(1, repo$core.code.turnover, repo$core.mail.turnover, repo$core.global.turnover)
  plot(repo$core.code.turnover, type="o", col=col.id[1], ylim=c(0, maxy), xaxt="n", ann=FALSE)
  abline(h=seq(0, maxy + 0.1, 0.1), v=1:length(repo$range), col="gray", lty=3)
  axis(1, at=seq(1, length(repo$range), 1))
  lines(repo$core.mail.turnover, type="o", col=col.id[2])
  lines(repo$core.global.turnover, type="o", col=col.id[3])
  title(main="Core members turnover", col.main="red", font.main=4)
  title(xlab="Ranges")
  title(ylab="Turnover (%)")
  legend("topright", c("Collaboration", "Communication", "Global"), cex=0.6, bg="white", fill=col.id)
  
  ## Num timezones
  barplot(repo$num.tz, ylab="# timezones", xlab="Ranges", 
          names.arg=seq(1, length(repo$range), 1), col="gray30", ylim=c(0, max(repo$num.tz) + 2), yaxt="n")
  title(main="Timezones", col.main="red", font.main=4)
  abline(h=1:(max(repo$num.tz) + 1), col="gray", lty=3)
  axis(2, at=seq(0,max(repo$num.tz) + 2, 2))
  
  ## Smelly quitters
  barplot(repo$ratio.smelly.quitters, ylab="Ratio", xlab="Ranges", 
         names.arg=seq(1, length(repo$range), 1), col="gray30", ylim=c(0, 1), yaxt="n")
  title(main="Ratio smelly quitters", col.main="red", font.main=4)
  box()
  abline(h=seq(0, 1, 0.1), col="gray", lty=3)
  axis(2, at=seq(0,1, 0.1))
  
  ## Smelly devs
  barplot(repo$ratio.smelly.devs, ylab="Ratio", xlab="Ranges", 
         names.arg=seq(1, length(repo$range), 1), col="gray30", ylim=c(0,1), yaxt="n")
  title(main="Ratio smelly devs", col.main="red", font.main=4)
  box()
  abline(h=seq(0, 1, 0.1), col="gray", lty=3)
  axis(2, at=seq(0, 1, 0.1))
  
  ## Closeness
  plot(repo$closeness.centr, type="o", col=col.id[1], ylim=c(0, 1), axes=FALSE, ann=FALSE)
  axis(1, at=seq(1, length(repo$range), 1))
  axis(2, at=seq(0, 1, 0.1))
  abline(h=seq(0, 1, 0.1), v=1:length(repo$range), col="gray", lty=3)
  lines(repo$betweenness.centr, type="o", col=col.id[2])
  lines(repo$degree.centr, type="o", col=col.id[3])
  title(main="Global network closeness", col.main="red", font.main=4)
  title(xlab="Ranges")
  title(ylab="Closeness")
  box()
  legend("topright", c("centralization", "betweenness", "degree"), 
         cex=0.6, bg="white", fill=col.id)
  
  ## Modularity
  plot(repo$global.mod, type="o", col=col.id[1], ylim=c(0,1), axes=FALSE, ann=FALSE)
  axis(1, at=seq(1, length(repo$range), 1))
  axis(2, at=seq(0, 1, 0.1))
  abline(h=seq(0, 1, 0.1), v=1:length(repo$range), col="gray", lty=3)
  lines(repo$code.mod, type="o", col=col.id[2])
  lines(repo$mail.mod, type="o", col=col.id[3])
  title(main="Network modularity", col.main="red", font.main=4)
  title(xlab="Ranges")
  title(ylab="Modularity")
  box()
  legend("topright", c("global", "collaboration", "communication"), 
         cex=0.6, bg="white", fill=col.id)
  
  ## Density
  plot(repo$density, type="o", col=col.id[1], xaxt="n", ann=FALSE)
  axis(1, at=seq(1, length(repo$range), 1))
  abline(h=seq(0, 1, 0.005), v=1:length(repo$range), col="gray", lty=3)
  title(main="Global network density", col.main="red", font.main=4)
  title(xlab="Ranges")
  title(ylab="Density")
  box()
}


## Generate latex report file about community smells and their
## Pearson and Spearman correlations with socio-technical
## quality metrics.
create.community.smells.report <- function(sociotechdir, project.name) {
  ## retrieve socio-technical analysis results
  df <- read.csv(file.path(sociotechdir, "report.csv"))[, -1]
  file.name <- file.path(sociotechdir, "report.tex")
  
  ## compute Pearson's and Spearman's correlations
  smells <- c("org.silo", "prima.donnas", "radio.silence", "black.cloud", "missing.links")
  metrics <- setdiff(colnames(df), c("range.date"))
  zero <- c("black.cloud", "global.turnover", "code.turnover", "ratio.smelly.quitters",
            "core.code.turnover", "core.mail.turnover", "core.global.turnover")
  ## Compute Pearson
  mat1.e <- matrix(, nrow=length(smells), ncol=length(metrics))
  mat1.p <- matrix(, nrow=length(smells), ncol=length(metrics))
  for (smell in 1:length(smells)) {
    for (metric in 1:length(metrics)) {
      if (metrics[metric] == smells[smell]) {
        next()
      }
      ## if the first value is going to be a 0 by default, skip it
      if((metrics[metric] %in% zero) || (smells[smell] %in% zero)) {
        cor <- cor.test(unlist(df[metrics[metric]])[-1], unlist(df[smells[smell]])[-1],
                        method="pearson")
        mat1.p[smell,metric] <- cor$p.value
        mat1.e[smell,metric] <- cor$estimate
      } else{
        cor <- cor.test(unlist(df[metrics[metric]]), unlist(df[smells[smell]]),
                        method="pearson")
        mat1.p[smell,metric] <- cor$p.value
        mat1.e[smell,metric] <- cor$estimate
      }
    }
  }
  pears.df.p <- data.frame(mat1.p)
  pears.df.e <- data.frame(mat1.e)
  colnames(pears.df.p) <- metrics
  rownames(pears.df.p) <- smells
  colnames(pears.df.e) <- metrics
  rownames(pears.df.e) <- smells
  
  ## Compute Spearman
  mat2.p <- matrix(, nrow=length(smells), ncol=length(metrics))
  mat2.e <- matrix(, nrow=length(smells), ncol=length(metrics))
  for (smell in 1:length(smells)) {
    for (metric in 1:length(metrics)) {
      if (metrics[metric] == smells[smell]) {
        next()
      }
      ## if the first value is going to be a 0 by default, skip it
      if((metrics[metric] %in% zero) || (smells[smell] %in% zero)) {
        cor <- cor.test(unlist(df[metrics[metric]])[-1], unlist(df[smells[smell]])[-1],
                        method="spearman")
        mat2.p[smell,metric] <- cor$p.value
        mat2.e[smell,metric] <- cor$estimate
      } else {
        cor <- cor.test(unlist(df[metrics[metric]]), unlist(df[smells[smell]]),
                        method="spearman")
        mat2.p[smell,metric] <- cor$p.value
        mat2.e[smell,metric] <- cor$estimate
      }
    }
  }
  spear.df.p <- data.frame(mat2.p)
  spear.df.e <- data.frame(mat2.e)
  colnames(spear.df.p) <- metrics
  rownames(spear.df.p) <- smells
  colnames(spear.df.e) <- metrics
  rownames(spear.df.e) <- smells
  
  ## write correlations to csv files
  write.csv(pears.df.e, file=file.path(sociotechdir, "pearson-estimate.csv"))
  write.csv(pears.df.p, file=file.path(sociotechdir, "pearson-pvalue.csv"))
  write.csv(spear.df.e, file=file.path(sociotechdir, "spearman-estimate.csv"))
  write.csv(spear.df.p, file=file.path(sociotechdir, "spearman-pvalue.csv"))
  
  ## generate lex file
  ## set the decimal digits
  dig <- c(0,0,0,0,0,4,4,4,0,4,0,4,0,0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,0,4,4,4)
  cat(c("\\documentclass{article}\n",
        "\\usepackage[landscape,a4paper,pdftex,top=5mm,bottom=5mm,left=5mm,right=5mm]{geometry}\n",
        "\\usepackage{graphicx}\n", "\\usepackage{calc}\n", "\\usepackage{lmodern}\n", "\\begin{document}\n",
        "\\setlength{\\parindent}{0pt}\n", "\\begin{center}\n", "\\begin{Large}\n",
        "\\textbf{Socio-technical analysis result (", project.name,")}\n", "\\end{Large}"),
      file=file.name)
  for (iter in 1:((ncol(df) / 25) + 1)) {
    ini <- (iter - 1) * 25 + 1
    fin <- min(ini + 24, ncol(df))
    tab <- xtable(df[ini:fin])
    digits(tab) <- c(0, dig[ini:fin])
    print(tab, type="latex", floating=FALSE, file=file.name, append=TRUE,
          sanitize.colnames.function=function(x) { return(paste("\\rotatebox{90}{", x, "}", sep="")) },
          NA.string="-")
  }
  
  cat(c("\n\\newpage\n", "\\begin{Large}\n",
        "\\textbf{Community smells: Pearson's correlation (", project.name,")}\n", "\\end{Large}"),
      file=file.name, append=TRUE)
  for (iter in 1:((ncol(pears.df.e) / 23) + 1)) {
    ini <- (iter - 1) * 23 + 1
    fin <- min(ini + 22, ncol(pears.df.e))
    print(xtable(pears.df.e[ini:fin]), type="latex", floating=FALSE, file=file.name, append=TRUE,
          sanitize.colnames.function=function(x) { return(paste("\\rotatebox{90}{", x, "}", sep="")) },
          NA.string="-")
  }
  cat(c("\n\\newpage\n", "\\begin{Large}\n", 
        "\\textbf{Community smells: Pearson's correlation - p-values (", project.name,")}\n", "\\end{Large}"),
      file=file.name, append=TRUE)
  for (iter in 1:((ncol(pears.df.p) / 23) + 1)) {
    ini <- (iter - 1) * 23 + 1
    fin <- min(ini + 22, ncol(pears.df.p))
    print(xtable(pears.df.p[ini:fin]), type="latex", floating=FALSE, file=file.name, append=TRUE,
          sanitize.colnames.function=function(x) { return(paste("\\rotatebox{90}{", x, "}", sep="")) },
          NA.string="-")
  }
  cat(c("\n\\newpage\n", "\\begin{Large}\n", 
        "\\textbf{Community smells: Spearman's correlation (", project.name,")}\n", "\\end{Large}"),
      file=file.name, append=TRUE)
  for (iter in 1:((ncol(spear.df.e) / 23) + 1)) {
    ini <- (iter - 1) * 23 + 1
    fin <- min(ini + 22, ncol(spear.df.e))
    print(xtable(spear.df.e[ini:fin]), type="latex", floating=FALSE, file=file.name, append=TRUE,
          sanitize.colnames.function=function(x) { return(paste("\\rotatebox{90}{", x, "}", sep="")) },
          NA.string="-")
  }
  cat(c("\n\\newpage\n", "\\begin{Large}\n", 
        "\\textbf{Community smells: Spearman's correlation - p-values (", project.name,")}\n", "\\end{Large}"),
      file=file.name, append=TRUE)
  for (iter in 1:((ncol(spear.df.p) / 23) + 1)) {
    ini <- (iter - 1) * 23 + 1
    fin <- min(ini + 22, ncol(spear.df.p))
    print(xtable(spear.df.p[ini:fin]), type="latex", floating=FALSE, file=file.name, append=TRUE,
          sanitize.colnames.function=function(x) { return(paste("\\rotatebox{90}{", x, "}", sep="")) },
          NA.string="-")
  }
  
  cat(c("\n\\end{center}\n", "\\end{document}\n", "\\grid"), file=file.name, append=TRUE)
}


##################### Socio-technical analysis #########################

## Main socio-technical analysis function
sociotechnical.analysis <- function (sociotechdir, codedir, conf) {
  ## retrieve tag methodology and ranges data
  releases.tag <- conf$tstamps.release$tag
  bound <- conf$boundaries
  ranges <- bound$cycle
  
  ## list of previous range data needed by the next range analysis
  prev.range.potential.black.cloud <- c()
  prev.all.devs.ids <- c()
  prev.code.devs.ids <- c()
  prev.code.core <- c()
  prev.mail.core <- c()
  prev.global.core <- c()
  prev.smelly.devs <- c()
  
  ## range analysis resuls - used to generate a global summary
  all.devs <- c()
  all.devs.code.sponsored <- c()
  all.devs.code.core <- c()
  all.devs.sponsored.core <- c()
  all.devs.mail.core <- c()
  all.devs.global.core <- c()
  all.devs.code.only.core <- c()
  all.devs.mail.only.core <- c()
  all.devs.ml.code.core <- c()
  all.devs.peripheral <- c()
  all.mail.only.devs <- c()
  all.code.only.devs <- c()
  all.mail.code.devs <- c()
  all.smell.org.silo <- c()
  all.smell.primadonnas <- c()
  all.smell.radiosilence <- c()
  all.smell.blackcloud <- c()
  all.smell.missing <- c()
  all.metric.congruence <- c()
  all.metric.communicability <- c()
  all.metric.global.turnover <- c()
  all.metric.developers.turnover <- c()
  all.metric.smelly.quitters <- c()
  all.metric.smelly.devs <- c()
  all.metric.global.centralization.closeness <- c()
  all.metric.global.centralization.betweenness <- c()
  all.metric.global.centralization.degree <- c()
  all.metric.code.modularity <- c()
  all.metric.mail.modularity <- c()
  all.metric.global.modularity <- c()
  all.metric.global.density <- c()
  all.metric.core.code.turnover <- c()
  all.metric.core.mail.turnover <- c()
  all.metric.core.global.turnover <- c()
  all.metric.global.truck <- c()
  all.metric.mail.truck <- c()
  all.metric.code.truck <- c()
  all.metric.timezones <- c()
  
  ## perform socio-techincal analysis for every range available
  for (range in 1:length(ranges)) {
    
    loginfo(paste("Analyzing range (",range, "/", length(ranges), "): ", ranges[range]))
    rangedir <-  file.path(codedir, ranges[range])
    
    ## retrieve collaboration, communication and global networks
    mail.graph <- load.mailinglist.graph(conf, bound$date.start[range], bound$date.end[range])
    code.graph <- load.code.graph(rangedir)
    global.graph <- load.global.graph(mail.graph, code.graph)
    ## find cummunities within the communication and collaboration graph
    mail.clusters <- walktrap.community(mail.graph, weights=E(mail.graph)$weight)
    code.clusters <- walktrap.community(code.graph, weights=E(code.graph)$weight)
    global.clusters <- walktrap.community(global.graph, weights=E(global.graph)$weight)
    
    ## Check community smells
    smell.org.silo <- community.smell.organisational.silo(mail.graph, code.graph)
    all.smell.org.silo[range] <- length(smell.org.silo)
    smell.radiosilence <- community.smell.radio.silence(mail.graph, mail.clusters)
    all.smell.radiosilence[range] <- length(smell.radiosilence)
    ## Black cloud smell should be iterated over time (present in the previous range)
    ## we need to change format to allow the instersection operation
    smell.potential.black.cloud.orig <- community.smell.potential.black.cloud(mail.graph, mail.clusters)
    smell.potential.black.cloud <-
      unlist(lapply(smell.potential.black.cloud.orig, function(x) {
        if (x[1] < x[2])
          paste(x[1],x[2],sep="-")
        else
          paste(x[2],x[1],sep="-")
      }))
    smell.black.cloud <- intersect(smell.potential.black.cloud, prev.range.potential.black.cloud)
    prev.range.potential.black.cloud <- smell.potential.black.cloud
    all.smell.blackcloud[range] <- length(smell.black.cloud)
    ## Reuse black cloud computation to compute prima-donnas. Prima-donnas can exist only when
    ## a black cloud exists
    smell.primadonnas <- c()
    if (length(smell.potential.black.cloud.orig) > 0) {
      smell.primadonnas <-
        community.smell.primadonnas(mail.graph, mail.clusters, code.graph, 
                                    precomputed.black=smell.potential.black.cloud.orig)
    } 
    all.smell.primadonnas[range] <- length(unique(unlist(smell.primadonnas)))  
    smell.missing.links <- community.smell.missing.links(mail.graph, code.graph,
                                                         precomputed.silo=smell.org.silo)
    all.smell.missing[range] <- length(smell.missing.links)

        
    ## Compute socio-technical metrics
    all.metric.congruence[range] <- community.metric.sociotechnical.congruence(mail.graph, code.graph)
    all.metric.communicability[range] <- community.metric.mean.communicability(mail.graph, code.graph)
    
    ## Core developers:
    ## retrieve core and peripheral devs of global, communication and coordination network
    devs.code.core <- c()
    devs.mail.core <- c()
    devs.global.core <- c()
    cen <- get.developer.class.centrality.undirected(code.graph) 
    ## convert names to ids
    for (dev in cen$core$author) {
      devs.code.core[length(devs.code.core) + 1] <- V(code.graph)[V(code.graph)$name %in% dev]$id
    }
    cen <- get.developer.class.centrality.undirected(mail.graph) 
    ## convert names to ids
    for (dev in cen$core$author) {
      devs.mail.core[length(devs.mail.core) + 1] <- V(mail.graph)[V(mail.graph)$name %in% dev]$id
    }
    cen <- get.developer.class.centrality.undirected(global.graph) 
    ## convert names to ids
    for (dev in cen$core$author) {
      devs.global.core[length(devs.global.core) + 1] <- V(global.graph)[V(global.graph)$name %in% dev]$id
    }
    all.devs.code.core[range] <- length(devs.code.core)
    all.devs.mail.core[range] <- length(devs.mail.core)
    all.devs.global.core[range] <- length(devs.global.core)
    devs.ml.code.core <- intersect(devs.code.core, devs.mail.core)
    all.devs.ml.code.core[range] <- length(devs.ml.code.core)
    all.devs.mail.only.core[range] <- all.devs.mail.core[range] - all.devs.ml.code.core[range]
    all.devs.code.only.core[range] <- all.devs.code.core[range] - all.devs.ml.code.core[range]

    ## truck number
    all.metric.code.truck[range] <- ((length(V(code.graph)) - all.devs.code.core[range]) 
                                     / length(V(code.graph)))
    all.metric.mail.truck[range] <- ((length(V(mail.graph)) - all.devs.mail.core[range]) 
                                     / length(V(mail.graph)))
    all.metric.global.truck[range] <- ((length(V(global.graph)) - all.devs.global.core[range])
                                       / length(V(global.graph)))
    
    ## Global turnover
    devs <- V(global.graph)$id
    left.all.devs <- setdiff(prev.all.devs.ids, devs)
    all.metric.global.turnover[range] <- (length(left.all.devs) / ((length(prev.all.devs.ids) + length(devs)) / 2))
    prev.all.devs.ids <- devs
    ## Developer turnover
    code.devs <- V(code.graph)$id
    left.code.devs <- setdiff(prev.code.devs.ids, code.devs)
    all.metric.developers.turnover[range] <- (length(left.code.devs) / ((length(prev.code.devs.ids) + length(code.devs)) / 2))
    prev.code.devs.ids <- code.devs
    ## core code devs turnover
    left.code.core <- setdiff(prev.code.core, devs.code.core)
    all.metric.core.code.turnover[range] <- (length(left.code.core) / ((length(prev.code.core) + length(devs.code.core)) / 2))
    if (is.na(all.metric.core.code.turnover[range])) {
      all.metric.core.code.turnover[range] <- 0
    }
    prev.code.core <- devs.code.core
    ## core mail devs turnover
    left.mail.core <- setdiff(prev.mail.core, devs.mail.core)
    all.metric.core.mail.turnover[range] <- (length(left.mail.core) / ((length(prev.mail.core) + length(devs.mail.core)) / 2))
    prev.mail.core <- devs.mail.core
    ## core global devs turnover
    left.global.core <- setdiff(prev.global.core, devs.global.core)
    all.metric.core.global.turnover[range] <- (length(left.global.core) / ((length(prev.global.core) + 
                                                                              length(devs.global.core)) / 2))
    prev.global.core <- devs.global.core
    
    ## Save devs number
    all.devs[range] <- length(devs)
    all.mail.code.devs[range] <- length(intersect(V(code.graph)$id, V(mail.graph)$id))
    all.mail.only.devs[range] <- length(V(mail.graph)$id) - all.mail.code.devs[range]
    all.code.only.devs[range] <- length(code.devs) - all.mail.code.devs[range]
    
    ## Compute the fraction of developers whom left the community and were involved in
    ## at least one community smell (Smelly quitters)
    smelly.quitter.devs <- intersect(prev.smelly.devs, left.all.devs)
    if (length(smelly.quitter.devs) == 0) {
      all.metric.smelly.quitters[range] <- 0
    } else {
      all.metric.smelly.quitters[range] <- length(smelly.quitter.devs) / length(left.all.devs)
    }
    
    ## Compute the fraction of developers involved in at least one community smell
    ## (smelly developers)
    memships <- membership(mail.clusters)
    smelly.devs <- unique(unlist(smell.missing.links)) # missing.links contain org.silo
    smelly.clusts <- unique(unlist(smell.primadonnas))
    smelly.devs <- unique(union(smelly.devs, unlist(smell.radiosilence)))
    for (black in unique(unlist(smell.black.cloud))) {
      smelly.clusts <- unique(union(smelly.clusts, memships[V(mail.graph)[V(mail.graph)$id == black]]))
    }
    for (clust in smelly.clusts) {
      smelly.devs <- 
        unique(union(smelly.devs, V(mail.graph)[memships == clust]$id))
    }
    prev.smelly.devs <- smelly.devs
    all.metric.smelly.devs[range] <- length(smelly.devs) / length(devs)
    
    ## Compute global network centralization, density and modularity
    all.metric.global.centralization.closeness[range] <- centralization.closeness(global.graph)$centralization
    all.metric.global.centralization.betweenness[range] <- centralization.betweenness(global.graph)$centralization
    all.metric.global.centralization.degree[range] <- centralization.degree(global.graph)$centralization
    all.metric.global.density[range] <- graph.density(global.graph)
    all.metric.code.modularity[range] <- modularity(code.graph, membership(code.clusters), weights=E(code.graph)$weight)
    all.metric.mail.modularity[range] <- modularity(mail.graph, membership(mail.clusters), weights=E(mail.graph)$weight)
    all.metric.global.modularity[range] <- modularity(global.graph, membership(global.clusters), 
                                                      weights=E(global.graph)$weight)
    
    ## Retrieve number of timezones involved
    all.metric.timezones[range] <- get.range.timezones.number(conf, bound$date.start[range], bound$date.end[range])
    
    ## Compute number of sponsored devs
    all.devs.code.sponsored[range] <- 0
    devs.sponsored <- c()
    for (dev in V(code.graph)$id) {
      if(is.person.sponsored.in.range(conf, dev, bound$date.start[range], bound$date.end[range])) {
        devs.sponsored[length(devs.sponsored) + 1] <- dev
      }
    }
    all.devs.code.sponsored[range] <- length(devs.sponsored)
    all.devs.sponsored.core[range] <- length(intersect(devs.code.core, devs.sponsored))

    
    ## Graph report creation
    pdf(file.path(sociotechdir, "ranges", paste(ranges[range], ".pdf", sep="")))
    ## Collaboration and communication graphs
    plot.igraph(
      mail.graph, vertex.size=3, vertex.label=NA, layout=layout.spring(mail.graph),
      vertex.color=membership(mail.clusters),
      main="Communication network from mailing lists"
    )
    plot.igraph(
      code.graph, vertex.size=3, vertex.label=NA, layout=layout.spring(code.graph), 
      vertex.color=membership(code.clusters),
      main="Collaboration network from VCS"
    )
    plot.igraph(
      global.graph, vertex.size=3, vertex.label=NA, layout=layout.spring(global.graph), 
      vertex.color=membership(global.clusters), 
      main="Global community network"
    )
    ## Community smell: Organisational silo effect
    if (length(smell.org.silo) > 0) {
      ## Convert dev ids into node ids
      silo.node.ids <- list()
      for (couple in smell.org.silo) {
        silo.node.ids[[length(silo.node.ids) + 1]] <-
          c(V(code.graph)[V(code.graph)$id == couple[1]], V(code.graph)[V(code.graph)$id == couple[2]])
      }
      V(code.graph)[V(code.graph) %in% unique(unlist(silo.node.ids))]$color <- "red"
      plot.igraph(
        code.graph, vertex.size=3, vertex.label=NA,  layout=layout.spring(code.graph),
        mark.groups=silo.node.ids, main="Community smell: Organisational silo effect", edge.color=NA
      )
      code.graph <- remove.vertex.attribute(code.graph, "color")
    } else {
      plot(0:10, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
      text(5, 8, "Community smell: no organisational silo effect detected!")
    }
    ## Community smell: Missing links
    if (length(smell.missing.links) > 0) {
      ## Convert dev ids into node ids
      missing.ids <- list()
      for (couple in smell.missing.links) {
        missing.ids[[length(missing.ids) + 1]] <-
          c(V(code.graph)[V(code.graph)$id == couple[1]], V(code.graph)[V(code.graph)$id == couple[2]])
      }
      V(code.graph)[V(code.graph) %in% unique(unlist(missing.ids))]$color <- "red"
      plot.igraph(
        code.graph, vertex.size=3, vertex.label=NA,  layout=layout.spring(code.graph),
        mark.groups=missing.ids, main="Community smell: missing links", edge.color=NA
      )
      code.graph <- remove.vertex.attribute(code.graph, "color")
    } else {
      plot(0:10, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
      text(5, 8, "Community smell: no missing links detected!")
    }
    ## Community smell: prima-donnas effect
    if(length(smell.primadonnas)>0) {
      primadonnasClusts <- list()
      comms <- communities(mail.clusters)
      for (primaClust in unique(unlist(smell.primadonnas))) {
        primadonnasClusts[[length(primadonnasClusts) + 1]] <-  comms[[primaClust]]
        V(mail.graph)[V(mail.graph)$name %in% comms[[primaClust]]]$color <- "red"
      }
      plot.igraph(mail.graph, mark.groups=primadonnasClusts, main="Community smell: Prima-donnas effect", 
                  vertex.size=3, layout=layout.spring(mail.graph), vertex.label=NA, edge.color=NA)
      mail.graph <- remove.vertex.attribute(mail.graph, "color")
    } else {
      plot(0:10, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
      text(5, 8, "Community smell: no prima-donnas effect detected!")
    }
    ## Community smell: Black-cloud effect
    if (length(smell.black.cloud) > 0) {
      g2 <- graph_from_edgelist(matrix(unlist(strsplit(smell.black.cloud, "-")), ncol=2, byrow=TRUE), directed=FALSE)
      V(g2)$id <- V(g2)$name
      V(g2)$name <- V(mail.graph)[V(mail.graph)$id %in% V(g2)$id]$name
      plot(g2, main="Community smell: Black clouds", vertex.size=3, vertex.label=NA,  
           layout=layout.spring(g2), edge.color="red") 
      rm(g2)
    } else {
      plot(0:10, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
      text(5, 8, "Community smell: no black-cloud effect detected!")
    }
    ## Community smell: radio silence
    if (length(unique(smell.radiosilence)) > 0) {
      V(mail.graph)[V(mail.graph)$id %in% unique(smell.radiosilence)]$color <- "green"
      plot.igraph(mail.graph, 
                  main="Community smell: Radio silence", vertex.size=3, vertex.label=NA,
                  layout=layout.spring(mail.graph))
      mail.graph <- remove.vertex.attribute(mail.graph, "color")
    } else {
      plot(0:10, type="n", xaxt="n", yaxt="n", bty="n", xlab="", ylab="")
      text(5, 8, "Community smell: no radio silence detected!")
    }
    dev.off()
  }
  
  
  ## Global report generation
  ranges.date <- paste(format(bound$date.start, format = "%Y-%m"), 
                     format(bound$date.end, format = "%Y-%m"), sep =" -- ")
  report.data <-
    data.frame(
      ranges, ranges.date, all.devs, all.mail.only.devs, all.code.only.devs, all.mail.code.devs, 
      round(all.mail.only.devs / all.devs, digits=4), round(all.code.only.devs / all.devs, digits=4), 
      round(all.mail.code.devs / all.devs, digits=4),
      all.devs.code.sponsored, round(all.devs.code.sponsored / all.devs, digits=4),
      all.devs.sponsored.core, round(all.devs.sponsored.core / (all.devs-all.mail.only.devs), digits=4),
      all.metric.timezones, all.devs.global.core, all.devs.mail.core, all.devs.code.core,
      all.smell.org.silo, all.smell.primadonnas, all.smell.radiosilence, all.smell.blackcloud, all.smell.missing,
      round(all.metric.congruence, digits=4), round(all.metric.communicability, digits=4),    
      round(all.metric.global.turnover, digits=4), round(all.metric.developers.turnover, digits=4), 
      round(all.metric.core.global.turnover, digits=4), round(all.metric.core.mail.turnover, digits=4), 
      round(all.metric.core.code.turnover, digits=4), round(all.metric.smelly.quitters, digits=4), 
      round(all.metric.smelly.devs, digits=4), round(all.metric.global.truck, digits=4), 
      round(all.metric.mail.truck, digits=4), round(all.metric.code.truck, digits=4), 
      round(all.metric.global.centralization.closeness, digits=4), 
      round(all.metric.global.centralization.betweenness, digits=4), 
      round(all.metric.global.centralization.degree, digits=4),
      round(all.metric.global.modularity, digits=4), round(all.metric.mail.modularity, digits=4),
      round(all.metric.code.modularity, digits=4), round(all.metric.global.density, digits=4),
      all.devs.mail.only.core, all.devs.code.only.core, all.devs.ml.code.core,
      round(all.devs.mail.only.core / (all.devs.mail.only.core+all.devs.code.only.core+all.devs.ml.code.core), digits=4),
      round(all.devs.code.only.core / (all.devs.mail.only.core+all.devs.code.only.core+all.devs.ml.code.core), digits=4),
      round(all.devs.ml.code.core / (all.devs.mail.only.core+all.devs.code.only.core+all.devs.ml.code.core), digits=4)
    )
  colnames(report.data) <- c("range", "range.date", "devs", "ml.only.devs", "code.only.devs", "ml.code.devs",
                             "perc.ml.only.devs", "perc.code.only.devs", "perc.ml.code.devs",
                             "sponsored.devs",  "ratio.sponsored", "sponsored.core.devs", 
                             "ratio.sponsored.core", "num.tz", "core.global.devs", "core.mail.devs", "core.code.devs",
                             "org.silo", "prima.donnas", "radio.silence", "black.cloud", "missing.links",
                             "st.congruence", "communicability", "global.turnover", "code.turnover",
                             "core.global.turnover", "core.mail.turnover", "core.code.turnover", 
                             "ratio.smelly.quitters", "ratio.smelly.devs", "global.truck", "mail.truck", "code.truck",
                             "closeness.centr", "betweenness.centr", "degree.centr", 
                             "global.mod", "mail.mod", "code.mod", "density",
                             "mail.only.core.devs", "code.only.core.devs", "ml.code.core.devs", 
                             "ratio.mail.only.core", "ratio.code.only.core", "ratio.ml.code.core")
  write.csv(report.data, file=file.path(sociotechdir, "report.csv"), row.names=FALSE)
  
  loginfo("Saving data ")
  write.sociotechnical.db(report.data, conf)
}

######################### Dispatcher ###################################
config.script.run({
  conf <- config.from.args(positional.args=list("resdir"), require.project=TRUE)
  sociotechdir <- file.path(conf$resdir, "st")
  codedir <- file.path(conf$resdir, conf$tagging)
  
  ## Create directory for socio-technical analysis results
  dir.create(sociotechdir, showWarnings=FALSE, recursive=TRUE)
  dir.create(file.path(sociotechdir, "ranges"), showWarnings=FALSE, recursive=TRUE)
  
  ## run socio-technical analysis
  sociotechnical.analysis(sociotechdir, codedir, conf)
  create.community.smells.report(sociotechdir, conf$project)
  create.global.report.graphs(sociotechdir)
})